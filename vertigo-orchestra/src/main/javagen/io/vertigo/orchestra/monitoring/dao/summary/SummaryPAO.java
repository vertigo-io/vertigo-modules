/*
 * vertigo - application development platform
 *
 * Copyright (C) 2013-2023, Vertigo.io, team@vertigo.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.vertigo.orchestra.monitoring.dao.summary;

import javax.inject.Inject;

import io.vertigo.core.lang.Assertion;
import io.vertigo.core.lang.Generated;
import io.vertigo.core.node.Node;
import io.vertigo.datamodel.task.TaskManager;
import io.vertigo.datamodel.task.definitions.TaskDefinition;
import io.vertigo.datamodel.task.model.Task;
import io.vertigo.datamodel.task.model.TaskBuilder;
import io.vertigo.datastore.impl.dao.StoreServices;

/**
 * This class is automatically generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 */
 @Generated
public final class SummaryPAO implements StoreServices {
	private final TaskManager taskManager;

	/**
	 * Constructeur.
	 * @param taskManager Manager des Task
	 */
	@Inject
	public SummaryPAO(final TaskManager taskManager) {
		Assertion.check().isNotNull(taskManager);
		//-----
		this.taskManager = taskManager;
	}

	/**
	 * Creates a taskBuilder.
	 * @param name  the name of the task
	 * @return the builder 
	 */
	private static TaskBuilder createTaskBuilder(final String name) {
		final TaskDefinition taskDefinition = Node.getNode().getDefinitionSpace().resolve(name, TaskDefinition.class);
		return Task.builder(taskDefinition);
	}

	/**
	 * Execute la tache TkGetExecutionSummariesByDate.
	 * @param dateMin Instant
	 * @param dateMax Instant
	 * @param status String
	 * @return DtList de OExecutionSummary dtcExecutionSummary
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			dataSpace = "orchestra",
			name = "TkGetExecutionSummariesByDate",
			request = "select 	* from (select \n" + 
 "         		from_exec.PRO_ID,\n" + 
 "         		from_exec.PROCESS_NAME,\n" + 
 "         		from_exec.PROCESS_LABEL,\n" + 
 "         		from_exec.SUCCESSFUL_COUNT,\n" + 
 "         		from_exec.ERRORS_COUNT,\n" + 
 "         		from_exec.RUNNING_COUNT,\n" + 
 "         		from_exec.AVERAGE_EXECUTION_TIME,\n" + 
 "         		from_exec.LAST_EXECUTION_TIME,\n" + 
 "         		from_exec.HEALTH,\n" + 
 "         		\n" + 
 "         		lat_planif.NEXT_EXECUTION_TIME,\n" + 
 "         		lat_planif.MISFIRED_COUNT\n" + 
 " 				from (\n" + 
 " 					select (select pro1.PRO_ID from o_process pro1 where pro1.name = exec.name and pro1.active_version is true) as PRO_ID,\n" + 
 " 						exec.name as PROCESS_NAME,\n" + 
 " 						exec.label as PROCESS_LABEL,\n" + 
 " 						sum(exec.SI_SUCCESS) as SUCCESSFUL_COUNT,\n" + 
 " 						sum(exec.SI_ERREUR) as ERRORS_COUNT,\n" + 
 " 						sum(exec.SI_RUNNING) as RUNNING_COUNT,\n" + 
 " 						round(extract('epoch' from avg(exec.execution_time))) as AVERAGE_EXECUTION_TIME,\n" + 
 " 						max(begin_time) as LAST_EXECUTION_TIME,\n" + 
 " 						case when min(exec.ERROR_RANK) = 1 then 'ERROR'\n" + 
 " 							when min(exec.ERROR_RANK) < 6 then 'WARNING'\n" + 
 " 							else 'SUCCESS' end as HEALTH\n" + 
 " 						\n" + 
 " 					from (\n" + 
 " 						select 	pro.pro_id,\n" + 
 " 							pro.name,\n" + 
 " 							pro.label,\n" + 
 " 							pre.END_TIME-pre.BEGIN_TIME as execution_time,\n" + 
 " 							case when pre.est_cd='DONE' then 1 else 0 end as SI_SUCCESS,\n" + 
 " 							case when pre.est_cd='ERROR' then 1 else 0 end as SI_ERREUR,\n" + 
 " 							case when pre.est_cd='RUNNING' then 1 else 0 end as SI_RUNNING,\n" + 
 " 							pre.begin_time,\n" + 
 " 							pre.EST_CD,\n" + 
 " 							case when pre.est_cd='ERROR' then\n" + 
 " 								rank() over(PARTITION by pro.name order by pre.begin_time desc)\n" + 
 " 								else null\n" + 
 " 							end as ERROR_RANK\n" + 
 " 						from o_process pro \n" + 
 " 						join o_process_execution pre on pre.pro_id = pro.pro_id\n" + 
 " 						where pre.begin_time between #dateMin# and #dateMax#\n" + 
 " 						\n" + 
 " 					) exec\n" + 
 " 					group by exec.name, exec.label\n" + 
 " 				) as from_exec\n" + 
 " 				\n" + 
 " 				join ( 	select 	planif.name,\n" + 
 " 								min(planif.waitingexpected_time) as NEXT_EXECUTION_TIME,\n" + 
 " 								sum(case when planif.SST_CD='MISFIRED' and planif.expected_time between #dateMin# and #dateMax# then 1 else 0 end) as MISFIRED_COUNT\n" + 
 " 						from (\n" + 
 " 							select p2.name,\n" + 
 " 								prp.expected_time as expected_time,\n" + 
 " 								case when prp.SST_CD = 'WAITING' then prp.expected_time else null end as waitingexpected_time,\n" + 
 " 								prp.SST_CD\n" + 
 " 							from o_process_planification prp\n" + 
 " 							join o_process p2 on p2.pro_id=prp.pro_id) as planif \n" + 
 " 						group by planif.name\n" + 
 " 					) lat_planif  on lat_planif.name = from_exec.PROCESS_NAME) as s\n" + 
 "         \n" + 
 " 			where 1=1\n" + 
 " 			<%if (\"ERROR\".equals(status)) {%>\n" + 
 " 				and s.ERRORS_COUNT > 0\n" + 
 " 			<%}%>\n" + 
 " 			<%if (\"DONE\".equals(status)) {%>\n" + 
 " 				and s.SUCCESSFUL_COUNT > 0\n" + 
 " 			<%}%>\n" + 
 " 			<%if (\"MISFIRED\".equals(status)) {%>\n" + 
 " 				and s.MISFIRED_COUNT > 0\n" + 
 " 			<%}%>\n" + 
 " 			;",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtOExecutionSummary", name = "dtcExecutionSummary")
	public io.vertigo.datamodel.data.model.DtList<io.vertigo.orchestra.monitoring.domain.summary.OExecutionSummary> getExecutionSummariesByDate(@io.vertigo.datamodel.task.proxy.TaskInput(name = "dateMin", smartType = "STyOTimestamp") final java.time.Instant dateMin, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateMax", smartType = "STyOTimestamp") final java.time.Instant dateMax, @io.vertigo.datamodel.task.proxy.TaskInput(name = "status", smartType = "STyOCodeIdentifiant") final String status) {
		final Task task = createTaskBuilder("TkGetExecutionSummariesByDate")
				.addValue("dateMin", dateMin)
				.addValue("dateMax", dateMax)
				.addValue("status", status)
				.addContextProperty("connectionName", io.vertigo.datastore.impl.dao.StoreUtil.getConnectionName("orchestra"))
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetExecutionSummaryByDateAndName.
	 * @param dateMin Instant
	 * @param dateMax Instant
	 * @param name String
	 * @return OExecutionSummary dtExecutionSummary
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			dataSpace = "orchestra",
			name = "TkGetExecutionSummaryByDateAndName",
			request = "select \n" + 
 "         		from_process.PRO_ID,\n" + 
 "         		from_process.PROCESS_NAME,\n" + 
 "         		from_process.PROCESS_LABEL,\n" + 
 "         		coalesce(from_exec.SUCCESSFUL_COUNT,0) as SUCCESSFUL_COUNT,\n" + 
 "         		coalesce(from_exec.ERRORS_COUNT,0) as ERRORS_COUNT,\n" + 
 "         		coalesce(from_exec.RUNNING_COUNT,0) as RUNNING_COUNT,\n" + 
 "         		from_exec.AVERAGE_EXECUTION_TIME,\n" + 
 "         		from_exec.LAST_EXECUTION_TIME,\n" + 
 "         		from_exec.HEALTH,\n" + 
 "         		\n" + 
 "         		lat_planif.NEXT_EXECUTION_TIME,\n" + 
 "         		coalesce(lat_planif.MISFIRED_COUNT, 0) as MISFIRED_COUNT\n" + 
 " 				from ( select  \n" + 
 " 						pro.PRO_ID as PRO_ID,\n" + 
 " 						pro.name as PROCESS_NAME,\n" + 
 " 						pro.label as PROCESS_LABEL\n" + 
 " 						from o_process pro \n" + 
 " 						where pro.NAME = #name#\n" + 
 " 						  and pro.ACTIVE_VERSION) as from_process\n" + 
 " 				left join lateral (\n" + 
 " 					select \n" + 
 " 						sum(exec.SI_SUCCESS) as SUCCESSFUL_COUNT,\n" + 
 " 						sum(exec.SI_ERREUR) as ERRORS_COUNT,\n" + 
 " 						sum(exec.SI_RUNNING) as RUNNING_COUNT,\n" + 
 " 						round(extract('epoch' from avg(exec.execution_time))) as AVERAGE_EXECUTION_TIME,\n" + 
 " 						max(begin_time) as LAST_EXECUTION_TIME,\n" + 
 " 						case when min(exec.ERROR_RANK) = 1 then 'ERROR'\n" + 
 " 							when min(exec.ERROR_RANK) < 6 then 'WARNING'\n" + 
 " 							else 'SUCCESS' end as HEALTH\n" + 
 " 						\n" + 
 " 					from (\n" + 
 " 						select 	pre.END_TIME-pre.BEGIN_TIME as execution_time,\n" + 
 " 							case when pre.est_cd='DONE' then 1 else 0 end as SI_SUCCESS,\n" + 
 " 							case when pre.est_cd='ERROR' then 1 else 0 end as SI_ERREUR,\n" + 
 " 							case when pre.est_cd='RUNNING' then 1 else 0 end as SI_RUNNING,\n" + 
 " 							pre.begin_time,\n" + 
 " 							pre.EST_CD,\n" + 
 " 							case when pre.est_cd='ERROR' then\n" + 
 " 								rank() over(PARTITION by pro.name order by pre.begin_time desc)\n" + 
 " 								else null\n" + 
 " 							end as ERROR_RANK\n" + 
 " 						from o_process pro \n" + 
 " 						left join o_process_execution pre on pre.pro_id = pro.pro_id\n" + 
 " 						where pre.begin_time between #dateMin# and #dateMax# and pro.name = #name#\n" + 
 " 						\n" + 
 " 					) exec\n" + 
 " 					\n" + 
 " 				) as from_exec on true\n" + 
 " \n" + 
 " 				left join lateral\n" + 
 " 				\n" + 
 " 				 ( 	select 	\n" + 
 " 								min(planif.waitingexpected_time) as NEXT_EXECUTION_TIME,\n" + 
 " 								sum(case when planif.SST_CD='MISFIRED' and planif.expected_time between #dateMin# and #dateMax# then 1 else 0 end) as MISFIRED_COUNT\n" + 
 " 						from (\n" + 
 " 							select p2.name,\n" + 
 " 								prp.expected_time as expected_time,\n" + 
 " 								case when prp.SST_CD = 'WAITING' then prp.expected_time else null end as waitingexpected_time,\n" + 
 " 								prp.SST_CD\n" + 
 " 							from o_process_planification prp\n" + 
 " 							join o_process p2 on p2.pro_id=prp.pro_id\n" + 
 " 							where p2.name = #name#) as planif \n" + 
 " 						where planif.name = from_process.PROCESS_NAME\n" + 
 " 						group by planif.name\n" + 
 " 					) lat_planif on true;",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtOExecutionSummary", name = "dtExecutionSummary")
	public io.vertigo.orchestra.monitoring.domain.summary.OExecutionSummary getExecutionSummaryByDateAndName(@io.vertigo.datamodel.task.proxy.TaskInput(name = "dateMin", smartType = "STyOTimestamp") final java.time.Instant dateMin, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateMax", smartType = "STyOTimestamp") final java.time.Instant dateMax, @io.vertigo.datamodel.task.proxy.TaskInput(name = "name", smartType = "STyOLibelle") final String name) {
		final Task task = createTaskBuilder("TkGetExecutionSummaryByDateAndName")
				.addValue("dateMin", dateMin)
				.addValue("dateMax", dateMax)
				.addValue("name", name)
				.addContextProperty("connectionName", io.vertigo.datastore.impl.dao.StoreUtil.getConnectionName("orchestra"))
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	private TaskManager getTaskManager() {
		return taskManager;
	}
}
